/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("AJE", [], factory);
	else if(typeof exports === 'object')
		exports["AJE"] = factory();
	else
		root["AJE"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/Editor.js":
/*!**************************!*\
  !*** ./src/js/Editor.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _templates_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./templates.js */ \"./src/js/templates.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"./src/js/helpers.js\");\n/* harmony import */ var _blocks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blocks.js */ \"./src/js/blocks.js\");\n/* harmony import */ var _inline_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inline.js */ \"./src/js/inline.js\");\n/* harmony import */ var _plugins_buffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/buffer.js */ \"./src/js/plugins/buffer.js\");\n\n\n;\n// import * as ModalFeedback from './plugins/modalFeedback.js'\n\n\n\n\n\nclass Editor {\n\n    // -----------------------------------------------------------------------------\n    // @section Initialisation\n    // -----------------------------------------------------------------------------\n\n    constructor( target, content, options ){\n        // Initialise options & toolbar\n        this.options = this.initOptions(options)\n        this.toolbar = this.initToolbar()\n        // this.clicked = false\n        // Initialise the editor\n        target.innerHTML = _templates_js__WEBPACK_IMPORTED_MODULE_0__.editor(this.toolbar, this.options)\n        this.editorNode = target.querySelector('.editor-body')\n        this.toolbarNode = target.querySelector('.editor-toolbar')\n        // Reset global range\n        this.range = false\n        // Add the content\n        const clean = this.getCleanData(content)\n        this.editorNode.innerHTML = clean\n        // Events\n        this.listenForMouseUpEvents()\n        this.listenForKeydownEvents()\n        this.listenForPasteEvents()\n        // Initialise buttons for standard and custom plugins\n        this.initialiseButtons()\n        // Initialise buffer handling\n        if ( this.options.bufferSize > 0 ){\n            this.listenForKeyupEvents()\n            setTimeout( () => _plugins_buffer_js__WEBPACK_IMPORTED_MODULE_4__.init({size:options.bufferSize, target:this.editorNode}), 100)\n        }\n    }\n\n    initOptions(options){   \n        // All standard supported tags\n        const tags = ['H1','H2','P', 'OL','UL', 'B', 'I', 'U']\n        const plugins = []\n        const headingNumbers = 'off'\n        const bufferSize = 10     \n        if ( options ){\n            options.tags = options.tags !== undefined ? options.tags : tags\n            options.plugins = options.plugins !== undefined ? options.plugins : plugins\n            options.headingNumbers = options.headingNumbers !== undefined ? options.headingNumbers : headingNumbers\n            options.bufferSize = options.bufferSize !== undefined ? Math.max(parseInt(options.bufferSize),bufferSize) : bufferSize\n        } else {\n            options = {\n                tags: tags,\n                plugins,\n                headingNumbers,\n                bufferSize\n            }\n        }\n        // Make sure all upper case\n        for( let i=0; i<options.tags.length; i++){\n            options.tags[i] = options.tags[i].toUpperCase()\n        }\n        console.log('options',options)\n        return options\n    }\n\n    initToolbar(){\n        let toolbar = []\n        // Add (filtered) standard buttons\n        _blocks_js__WEBPACK_IMPORTED_MODULE_2__.buttons.forEach( button => {\n            if ( options.tags.includes(button.tag) ){\n                toolbar.push(button)\n            }\n        })\n        _inline_js__WEBPACK_IMPORTED_MODULE_3__.buttons.forEach( button => {\n            if ( options.tags.includes(button.tag) ){\n                toolbar.push(button)\n            }\n        })\n        // Add optional copy-paste buffering\n        if ( this.options.bufferSize > 0 ){\n            toolbar = [...toolbar, ..._plugins_buffer_js__WEBPACK_IMPORTED_MODULE_4__.buttons]\n        }\n        // Add custom plugins\n        this.options.plugins.forEach( plugin => {\n            plugin.buttons.forEach( button => {\n                button.type = 'custom'\n                toolbar = [...toolbar, button]\n            })\n        })\n        console.log('toolbar',toolbar)\n        return toolbar\n    }\n\n    initialiseButtons(){\n        // Do any custom setup required\n        this.toolbar.forEach( button => {\n            // Add dom element to the button\n            button.element = this.toolbarNode.querySelector(`#${button.tag}`)\n            // Set disabled flag on element. Requires range and button to be passed in\n            // The toolbarButton class defaults has default method which can be overridden\n            // by adding a disabled method in the button options\n            button.disabled(false)\n            // Perform any button initialisation by passing in the editorNode\n            if ( \"init\" in button ){\n                button.init(this.editorNode)\n            }\n            // Some button have shortcuts in which case listen for\n            if ( \"shortcut\" in button && \"click\" in button){\n                this.editorNode.addEventListener('keydown', event =>{\n                    if ( event.key === button.shortcut ){\n                        // Prevent default so key not echo'd to the screen\n                        event.preventDefault()\n                        // Stop propagation to prevent other event handlers responding\n                        event.stopPropagation()\n                        // Trigger the dialogue witht he then current range\n                        button.click(this.range)\n                    }\n                })\n            }\n            // All button have a click method\n            if ( \"click\" in button ){\n                button.element.addEventListener('click', event => {\n                    // Prevent default action for all buttons when have no range \n                    // and not the undo-redo buffer buttons\n                    if ( this.range === false && button.type !== 'buffer' ){\n                        event.preventDefault()\n                        return\n                    }\n                    this.debugRange(this.range)\n                    this.clickToolbarButton(button)\n                })\n            } else {\n                console.debug(`The ${button.tag} button is missing a mandatory click handler`)\n            }\n        })\n    }\n\n    // -----------------------------------------------------------------------------\n    // @section Mouse up events\n    // -----------------------------------------------------------------------------\n   \n    \n\n    listenForMouseUpEvents(){\n        this.editorNode.addEventListener('mouseup', event => {\n            if ( this.editorOrtoolbar( event.target ) ){\n                this.handleMouseUp() \n            } else {\n                this.handleEditorBlur()\n            }\n        })\n        // this.editorNode.addEventListener('mouseup', () => this.handleMouseUp(true))\n        // Use timeout on blur so buttons still active when first clicked from editor\n        // this.editorNode.addEventListener('blur', () => {\n        //     setTimeout( ()=>this.handleEditorBlur(), 200 )\n        // })\n        // this.editorNode.addEventListener('blur', event => {\n        //     console.log('target', event.target)\n        //     if ( editorOrtoolbarButtonParent( event.target ){\n        //     this.handleEditorBlur()\n        // })\n\n        // document.body.addEventListener('mouseup', event => {\n        //     console.log('moused up with target', event.target)\n        // })\n    }\n\n    handleEditorBlur( event ){\n        // if ( this.clicked == false ) {\n            console.log('editor blurred')\n            this.toolbar.forEach( button => {\n                button.disabled( false )\n                button.element.classList.remove('active')\n            })\n        // }\n        // this.clicked = false\n    }\n\n    editorOrtoolbar(node){\n        while ( node != document.body ){\n            if ( node == this.editorNode || node == this.toolbarNode ){\n                return true\n            }\n            node = node.parentNode\n        }\n        return false\n    }\n\n    handleMouseUp(){\n\n        // this.clicked = true\n        console.log('Handle mouse up')\n        this.range = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.getRange()\n        console.log('handleMouseUp range=',this.range)\n        this.debugRange(this.range)\n        let formats = []\n        if ( this.range !== false ){\n            // If enter cursor in an empty editor then make this a paragraph\n            // rather than raw text\n            if ( this.range.blockParent == this.editorNode && this.editorNode.innerText == ''){\n                this.insertParagraph()\n            }\n            // Highlight \"selected\" custom blocks - in practice this won't be triggered\n            // since the custom click functions will intervene\n            if ( _helpers_js__WEBPACK_IMPORTED_MODULE_1__.isCustom(this.range.blockParent) ){\n                this.highlightCustomNode(this.range.blockParent)\n            }\n            // Get the applied formats for the range selected (all way up to the highest parent \n            // inside the editor)\n            formats = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.appliedFormats(this.range.startContainer, this.editorNode, this.range.rootNode, '')\n            console.log('Applied formats',formats)\n        }\n        this.toolbar.forEach( button => {\n            // Trigger disabled method on each button\n            button.disabled( this.range )\n            // Set active state of button\n            if ( formats.includes(button.tag) ){\n                button.element.classList.add('active')\n            } else {\n                button.element.classList.remove('active')\n            }\n\n\n            // // Buffering is handled separately\n            // if ( button.type !== 'buffer' ){\n            //     // Reset flags\n            //     if ( this.range === false ){\n            //         button.element.disabled = true\n            //         button.element.classList.remove('active')\n            //     } else {\n            //         button.element.disabled = button.disabled(this.range)\n\n                    \n            //         // false\n            //         // if ( \"disabled\")\n            //         // Check whether selection means button should be shown as active or not\n            //         if ( formats.includes(button.tag) ){\n            //             button.element.classList.add('active')\n            //         } else {\n            //             button.element.classList.remove('active')\n            //         }\n            //     }\n            // }\n        })\n    }\n\n    insertParagraph(){\n        let p = document.createElement('P')\n        // Create a placeholder to ensure set cursor works\n        p.innerText = '\\n'\n        p = this.editorNode.appendChild(p)\n        _helpers_js__WEBPACK_IMPORTED_MODULE_1__.setCursor( p, 0)\n    }\n\n    // -----------------------------------------------------------------------------\n    // @section Toolbar button clicks\n    // -----------------------------------------------------------------------------\n    \n    clickToolbarButton(button){\n        //const button = this.toolbar.find( button => button.tag==element.id )\n        console.log('clicked button',button.tag)\n        // All buttons must have a click method so invoke\n        this.range = button.click(this.range)\n        // Reset event handlers for any buttons that require it\n        this.updateEventHandlers()\n        if ( this.range == undefined ){\n            this.range = false\n        }\n        console.log('range',this.range)\n        this.handleMouseUp()\n    }\n\n\n    // -----------------------------------------------------------------------------\n    // @section Keydown events\n    // -----------------------------------------------------------------------------\n    \n    listenForKeydownEvents(){\n        this.editorNode.addEventListener('keydown', event => {\n            console.log('control key?',event.ctrlKey)\n            console.log('key',event.key)\n            // CCheck if a modal dialogue is shown - ignore key entry?\n            if ( document.querySelectorAll('.show').length > 0 ){\n                event.preventDefault()\n            // Override normal browser enter key action\n            } else if ( event.key == 'Enter' ) {\n                if ( this.handleEnter() ){\n                    event.preventDefault()\n                }\n            // Prevent deletion of customised blocks\n            } else if ( event.key == 'Backspace' || event.key == 'Delete' || \n                        (event.ctrlKey && event.key == 'd') ){\n                if ( this.handleDelete(event.key) ){\n                    event.preventDefault()\n                }\n            // Undo/redo events\n           } else if (this.bufferSize>0){\n                if ( (event.ctrlKey || event.metaKey) && event.key == 'z' ){\n                    event.preventDefault()\n                    // Redo\n                    if ( event.shiftKey  ){\n                        const button = this.toolbar.find( b => b.tag == 'REDO')\n                        if ( button.click() ){\n                            this.updateEventHandlers()\n                        }\n                    // Undo\n                    } else {\n                        const button = this.toolbar.find( b => b.tag == 'UNDO')\n                        if ( button.click() ){\n                            this.updateEventHandlers()\n                        }\n                    }\n                }\n            }\n        })\n    }\n\n    handleEnter(){\n        this.range = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.getRange()\n        this.debugRange(this.range)\n        if ( this.range === false ){\n            return\n        }\n        const custom = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.isCustom(this.range.blockParent) \n        const endNormal = this.range.endContainer.textContent.trim().length == this.range.endOffset\n        let handled = false\n        if ( custom || endNormal ) {\n            let p = document.createElement('P')\n            p.innerText = '\\n'\n            p = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.insertAfter( p, this.range.blockParent )\n            _helpers_js__WEBPACK_IMPORTED_MODULE_1__.setCursor( p, 0 )\n            handled = true\n        }\n        if ( custom ){\n            this.highlightCustomNode(false)\n        }\n        // Get the new range\n        this.range = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.getRange()\n        this.debugRange(this.range)\n        return handled\n    }\n\n    /**\n     * \n     * @returns boolean true if need to prevent default action\n     */\n    handleDelete(key){\n        if ( key == 'd' ){\n            key = 'Delete'\n        }\n        const range = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.getRange()\n        this.debugRange(range)\n        console.log('range=',range)\n        if ( range ){\n            const example = this.toolbar.find(button => button.type==='custom')\n            const title = 'Information'\n            const message = `To delete a custom element (such as an ${example.tag}) you need to edit it by clicking it and choosing Delete.`\n            // Single selection\n            if ( range.collapsed ){\n                console.log('Single selection')\n                console.log('range length', range.endContainer.textContent.trim().length)\n                console.log('range endOffset', range.endOffset)\n                // Check for back spacing from a single selection point\n                if ( key == 'Backspace' && range.startOffset == 0 ){\n                    // Back spacing into a non-editable block?\n                    const previous = range.blockParent.previousElementSibling\n                    if ( previous && previous.innerHTML.includes('contenteditable=\"false\"') ){\n                        Feedback.show(title, message)\n                        return true\n                    }\n                // Forward delete in a none-editable block?\n                } else if ( key == 'Delete' && range.endContainer.textContent.trim().length == range.endOffset ){\n                    console.log('Deleting from end container')\n                    const next = range.endContainer.nextElementSibling\n                    console.log('next',next)\n                    if ( next && next.getAttribute(\"contenteditable\") == 'false' ){\n                        Feedback.show(title, message)\n                        return true\n                    }\n                }\n            // Back spacing or deleting in a multiple selection\n            } else {\n                // Loop from start container to end container checking for a non-editable block\n                let parent = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.getParentBlockNode(range.startContainer)\n                const endParent = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.getParentBlockNode(range.endContainer)\n                while ( parent !== endParent ){\n                    if ( parent.innerHTML.includes('contenteditable=\"false\"') ){\n                        Feedback.show(title, message)\n                        return true\n                    }\n                    parent = parent.nextElementSibling\n                }\n            }\n        }\n        return false\n    }\n\n    // -----------------------------------------------------------------------------\n    // @section Keyup events\n    // -----------------------------------------------------------------------------\n    \n    listenForKeyupEvents(){\n        this.handleKeyup = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.debounce(this.handleKeyupDelayed,500)\n        this.editorNode.addEventListener( 'keyup', event => {\n            console.log('event',event)\n            const ignore = ['ArrowDown','ArrowUp','ArrowLeft','ArrowRight','End','Home']\n            if ( ignore.includes(event.key) === false ){\n                this.handleKeyup() \n            }\n        })\n    }\n\n    handleKeyupDelayed(...args){\n        console.log('args',args)\n        _plugins_buffer_js__WEBPACK_IMPORTED_MODULE_4__.update()\n    }\n\n\n    // -----------------------------------------------------------------------------\n    // @section Custom events\n    // -----------------------------------------------------------------------------\n    \n\n\n    updateEventHandlers(){\n        this.toolbar.forEach( button => {\n            if ( 'addEventHandlers' in button ){\n                button.addEventHandlers()\n            }\n        })\n    }\n\n\n    // -----------------------------------------------------------------------------\n    // @section Paste events\n    // -----------------------------------------------------------------------------\n    \n    listenForPasteEvents(){\n        const events = ['cut', 'copy','paste']\n        events.forEach( evt =>\n            this.editorNode.addEventListener(evt, event=>{\n                if ( this.handleCutCopyPaste() ){\n                    event.preventDefault()\n                }\n                // Update buffer\n                setTimeout( ()=>this.handleKeyup(this), 1)\n            })\n        )\n    }\n\n    handleCutCopyPaste(){\n        console.log('Detected cut-copy-paste event')\n        const range = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.getRange()\n        this.debugRange(range)\n        // Ensure have a range that is not collapsed\n        if ( range==false || range.collapsed ){\n            return false\n        }\n        // Loop from start container to end container checking for a non-editable block\n        let parent = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.getParentBlockNode(range.startContainer)\n        const endParent = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.getParentBlockNode(range.endContainer)\n        while ( parent !== endParent ){\n            if ( parent.innerHTML.includes('contenteditable=\"false\"') ){\n                const example = this.toolbar.find(button => button.type==='custom')\n                const title = 'Information'\n                const message = `Cut, copy and paste (of/over) selections with custom elements (such as ${example.tag}s) is not supported. Please modify your selection and try again.`\n                Feedback.show(title, message)\n                return true\n            }\n            parent = parent.nextElementSibling\n        }\n        return false\n    }\n\n\n    // -----------------------------------------------------------------------------\n    // @section Other methods\n    // -----------------------------------------------------------------------------\n    \n    getCleanData(content){\n        let node\n        if ( content !== undefined ){\n            node = document.createElement('div')\n            node.innerHTML = content\n        } else {\n            node = this.editorNode.cloneNode(true)\n        }\n        const customButtons = this.toolbar.filter( button => button.type==='custom')\n        _helpers_js__WEBPACK_IMPORTED_MODULE_1__.cleanForSaving(node, customButtons)\n        return node.innerHTML\n    }\n \n    highlightCustomNode(node){\n        // Remove \"selected\" class from all custom elements and then add back into this one\n        const customs = this.editorNode.querySelectorAll('[contenteditable=false]')\n        customs.forEach(custom=>custom.classList.remove('selected'))\n        if ( node ){\n            node.classList.add('selected')\n        }\n    }\n\n    debugRange(range){\n        const debug = document.getElementById('debug')\n        if ( debug == null ){\n            return\n        }\n        console.warn('debugRange',range)\n        if ( range === false ){\n            debug.innerHTML = 'No range selected'\n        } else {\n            debug.innerHTML = `\n                <p>Block parent: ${range.blockParent.tagName}</p>\n                <p>commonAncestorContainer: ${range.commonAncestorContainer.tagName ? range.commonAncestorContainer.tagName : range.commonAncestorContainer.textContent}</p>\n                <p>rootNode: ${range.rootNode.tagName}</p>\n                <p>collapsed: ${range.collapsed}</p>\n                <p>startContainer: ${range.startContainer.tagName ? range.startContainer.tagName : range.startContainer.textContent}</p>\n                <p>startOffset: ${range.startOffset}</p>\n                <p>endContainer: ${range.endContainer.tagName ? range.endContainer.tagName : range.endContainer.textContent}</p>\n                <p>endOffset: ${range.endOffset}</p>`\n        }\n    }\n\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Editor);\n\n\n//# sourceURL=webpack://AJE/./src/js/Editor.js?");

/***/ }),

/***/ "./src/js/blocks.js":
/*!**************************!*\
  !*** ./src/js/blocks.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buttons\": () => (/* binding */ buttons)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/js/helpers.js\");\n/* harmony import */ var _phase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./phase.js */ \"./src/js/phase.js\");\n/* harmony import */ var _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/icons.js */ \"./src/js/plugins/icons.js\");\n/* harmony import */ var _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/ToolbarButton.js */ \"./src/js/plugins/ToolbarButton.js\");\n\n\n\n\n\nlet editorNode\nlet formatType = ''\nlet formatAction = ''\nlet newFormat = ''\nlet previousFormats = []\nlet lastNodeAdded = false\nlet fragmentNode\n\nfunction getListAndBlockFormats( node, formats ){\n    // Always set old formats to the original\n    const oldFormats = [...formats.oldFormats, node.tagName]\n    let newFormats = []\n    // Pre and post phases set the new format to be the \n    // same as the old format\n    if ( _phase_js__WEBPACK_IMPORTED_MODULE_1__.pre() || _phase_js__WEBPACK_IMPORTED_MODULE_1__.post() ){\n        // console.log(`1. Pushing ${node.tagName} to formats`)\n        newFormats = [...formats.newFormats, node.tagName]\n        return {newFormats,oldFormats}\n    }\n    // During phase\n    //\n    // New block formatting (not list) - apply new format\n    if ( formatType == 'block' ){\n        // console.log(`Format type = ${this.formatType}`)\n        // console.log(`2. new block format ${this.newFormat}`)\n        newFormats = [ newFormat ]\n        return {newFormats,oldFormats}\n    }\n    //\n    // New list formatting\n    if ( _phase_js__WEBPACK_IMPORTED_MODULE_1__.first() ){\n        // console.log(`3. First node with new list format ${newFormat}`)\n        // Reformatting a list item?\n        if ( node.tagName == 'LI' ){\n            // console.log('3.1 Processing LI')\n            const parentListContainer = node.parentNode\n            // First in list - in which case modify list type\n            if ( parentListContainer.firstElementChild == node ){\n                // console.log( '3.1.1 First item in a list - replace existing list')\n                // Pop off the old list format and replace with the new one plus the LI\n                newFormats.pop()\n                newFormats.push(newFormat)\n                newFormats.push('LI')\n                // console.log('3.1.2 new list formats', formats.newFormats.join(' '))\n            // Else create a new indented list\n            } else {\n                // console.log( '3.1.3 Subsequent item in a list - indent a new list')\n                newFormats.push('LI')\n                newFormats.push(newFormat)\n                newFormats.push('LI')\n                // console.log('3.1.4 new list formats', formats.newFormats.join(' '))\n            }\n        // This is a different block node (e. H1, P) or a list container node - therefore start a new list\n        } else {\n            // console.log( 'Converting a block node')\n            newFormats.push(newFormat)\n            newFormats.push('LI')\n            // console.log('3.2 new list formats', formats.newFormats.join(' '))\n        }\n        return {newFormats,oldFormats}\n    }\n    // During but not first node phase - reuse previously defined list formats\n    // Slice produces a shallow copy (in this case of all elements)\n    newFormats = previousFormats.slice()\n    // console.log(`4. Reusing initial list formatting ${formats.newFormats.join(' ')}`)\n    return {newFormats,oldFormats}\n}\n    \n/**\n * Returns the html content of a node including its child nodes\n * @todo Could go into Helpers but not used elsewhere yet\n * @param {*} node \n * @returns string html content\n */\nfunction getBlockHTML(node){\n    let html = ''\n    // Extract all text, inline formats and protected node content from the node\n    node.childNodes.forEach( child => {\n        // Plain text node\n        if ( child.nodeType === 3 ) {\n            let text = child.textContent\n            // Trim text nodes with CR's\n            if ( text.includes('\\n') ){\n                text = text.trim()\n            }\n            html += text\n        // Inline, custom node or line break\n        } else if ( _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInline(child) || _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isCustom(child) || child.tagName==='BR'){\n            html += child.outerHTML \n        }\n    })\n    return html\n}\n    \nfunction saveBlockContent( node, formats ){\n    let n\n    let target = fragmentNode\n    let html = getBlockHTML(node)\n    let currentFormats = []\n    if ( _phase_js__WEBPACK_IMPORTED_MODULE_1__.during() ){\n        currentFormats = formats.newFormats\n    } else {\n        currentFormats = formats.oldFormats\n    }\n    let lastFormat = currentFormats.slice(-1)[0]\n    // console.log('html',html)\n    // Don't include what? @todo rest of comment!\n    if ( html == '' && node.innerHTML.includes('<') ){\n        return\n    }\n    // First time - apply all formats\n    if ( previousFormats.length == 0 ){\n        // console.log('0. Original target',target.outerHTML)\n        currentFormats.forEach( format => {\n            n = document.createElement( format )\n            target = target.appendChild( n )\n            console.log('1. First content - moving target to',target.outerHTML)\n        })\n    // New tree larger and the previous formats are a subset?\n    // Compare formatting and add to appropriate end of tree\n    } else if ( currentFormats.length > previousFormats.length ){\n        // console.log('2. Current formats longer than previous formats')\n        if ( _helpers_js__WEBPACK_IMPORTED_MODULE_0__.arraySubset( previousFormats, currentFormats ) ){\n            // console.log('2.1 Current formats are a superset of previous formats')\n            for( let i=0; i<previousFormats.length; i++){\n                target = target.lastElementChild\n                console.log('2.2 New formats superset - moving target to',target.outerHTML)\n            }\n            for( let i=previousFormats.length; i < currentFormats.length; i++ ){\n                n = document.createElement( currentFormats[i] )\n                target = target.appendChild( n )\n                console.log('2.3 New formats superset - moving target to',target.outerHTML)\n            }\n        }\n    // Formatting is the same as previously\n    } else if ( _helpers_js__WEBPACK_IMPORTED_MODULE_0__.arraysEqual(currentFormats,previousFormats) ){\n        if ( lastNodeAdded && lastNodeAdded != fragmentNode ){\n            target = lastNodeAdded.parentNode\n        }\n        n = document.createElement( lastFormat )\n        target = target.appendChild( n )\n        // console.log('3. Formats equal - moving target to',target.outerHTML)\n    }\n    // New formatting smaller or different - find where in tree to append\n    if ( target == fragmentNode ){\n        // console.log('4. New formatting smaller or different')\n        let startIndex = 0\n        currentFormats.forEach( (format,index) => {\n            if ( format == previousFormats[index] ){\n                // Exclude the last format if it is an LI as we need \n                // to add the LI to the previous list parent\n                if ( (index==(currentFormats.length-1) && format=='LI') == false ){\n                    target = target.lastElementChild\n                    // console.log('4.1 Move target node to', target.outerHTML)\n                    startIndex ++\n                }\n            }\n        })\n        for( let i=startIndex; i<currentFormats.length; i++ ){\n            n = document.createElement( currentFormats[i] )\n            target = target.appendChild( n )\n            // console.log('4.2 Starting new formats - moving target to',target.outerHTML)\n        }\n    }\n    lastNodeAdded = target\n    previousFormats = currentFormats.slice()\n    // Add the content\n    if ( html != '' ){\n        target.innerHTML = html\n        // console.log('target with new content', target.outerHTML)\n        // console.log('fragmentNode',fragmentNode.innerHTML)\n    }\n}\n    \nfunction parseListsAndBlocks( node, formats ){\n    // console.log( `%cparseListsAndBlocks ${node.tagName}`,'background:green;color:white;padding:0.5rem')\n    // console.log( `HTML [${node.innerHTML.trim()}]`)\n    // console.log( `node formats on entry`,formats.oldFormats)\n    // Define the formats for this node only\n    let nodeFormats = {\n        oldFormats:[],\n        newFormats:[]\n    } \n    if ( node != editorNode ){\n        _phase_js__WEBPACK_IMPORTED_MODULE_1__.set( node )\n        // Get the old and new formats\n        nodeFormats = getListAndBlockFormats( node, formats )\n        console.log( `old node formats`,nodeFormats.oldFormats)\n        console.log( `new node formats`,nodeFormats.newFormats)\n        // Save content of text nodes and protected nodes\n        saveBlockContent( node, nodeFormats )\n    }\n    // if ( node.childNodes.length == 0 ){\n    //     //console.log('Finished parsing this branch')\n    //     return\n    // }\n    node.childNodes.forEach( child => {\n        if ( child.nodeType !== 3 &&\n             _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInline(child) == false &&\n             _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isCustom(child) == false ){\n            // console.log(`Moving to child ${child.tagName}`)\n            parseListsAndBlocks( child, nodeFormats  ) \n        }\n    })\n    // console.log(`Finished this branch - processed ${children} children`)\n}\n\n// Optional initialisation method that takes in the editor node\nconst init = function(editor){\n    if ( editorNode == undefined ){\n        editorNode = editor\n    }\n}\n\nconst click = function( range ){\n    console.warn('range',range)\n    // const offset = range.endOffset\n    // Initialisation\n    formatType = this.type\n    formatAction = 'apply'\n    if ( this.tag == 'CLEAR' || this.element.getAttribute('data-active') ){\n        formatAction = 'remove'\n    }\n    // console.log('Format action', formatAction)\n    newFormat = this.tag\n    if ( this.type == 'block' && formatAction == 'remove' ){\n        newFormat = 'P'\n    }\n    previousFormats = []\n    lastNodeAdded = false\n    // Ensure start from a block node\n    range.rootNode = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.getTopParentNode( range.rootNode, editorNode )\n    const firstParentNode = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.getTopParentNode( range.startContainer, editorNode )\n    const endParentNode = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.getTopParentNode( range.endContainer, editorNode )\n    // Find the end target as the next node following the last in the selection\n    // Use this at the end to reset the selection\n    let endTarget = editorNode\n    if ( endParentNode != editorNode.lastElementChild ){\n        endTarget = endParentNode.nextElementSibling\n    }\n    // Init phase for block formatting\n    _phase_js__WEBPACK_IMPORTED_MODULE_1__.init(range, true)\n    // console.log(`%creFormatBlock with new format ${button.tag}`,'background-color:red;color:white;padding:0.5rem')\n    // Just parse the root node if the start and end belong to the same parent\n    if ( firstParentNode == endParentNode ){\n        fragmentNode = document.createElement('DIV')\n        parseListsAndBlocks( range.rootNode, {oldFormats:[], newFormats:[]} )\n        // console.log( 'fragment', fragmentNode.innerHTML)\n        if ( range.rootNode == editorNode ){\n            range.rootNode.innerHTML = fragmentNode.innerHTML //+ Helpers.BLOCK_END_MARKER\n        } else {\n            range.rootNode.outerHTML = fragmentNode.innerHTML //+ Helpers.BLOCK_END_MARKER\n        }\n    } else {\n        let startNodeFound = false\n        let endNodeFound = false\n        fragmentNode = document.createElement('DIV')\n        range.rootNode.childNodes.forEach( node => {\n            if ( node.nodeType === 3 ){\n                return\n            }\n            if ( node == firstParentNode ){\n                startNodeFound = true\n            } \n            // Start processing once start node found\n            if ( startNodeFound && endNodeFound==false ) {\n                // console.log( `%cparse top level node ${node.tagName}`,'background:orange;color:white;padding:0.5rem')\n                // Check for block (as opposed to list formatting) and start a new fragment\n                if ( formatType == 'block' ){\n                    previousFormats = []\n                    lastNodeAdded = false\n                    fragmentNode = document.createElement('DIV')\n                }\n                parseListsAndBlocks( node, {oldFormats:[], newFormats:[]} )\n                if ( this.type == 'block' ){\n                    // console.log( 'fragment', this.fragmentNode.innerHTML)\n                    node.outerHTML = fragmentNode.innerHTML\n                } else {\n                    node.setAttribute('data-remove',true)\n                }\n\n            }\n            // Stop processing when end node found. If formatting a list write out the \n            // fragment\n            if ( node == endParentNode ){\n\n                endNodeFound = true \n                \n                if ( formatType == 'list' ){\n                    console.log( 'fragment', fragmentNode.innerHTML)\n                    node.outerHTML = fragmentNode.innerHTML \n                }\n                let removeNodes = editorNode.querySelectorAll('[data-remove=true]')\n                removeNodes.forEach( removeNode => removeNode.remove() )\n            }\n        })\n\n    }\n    // Reset the selection\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.setCursorToTargetNode(editorNode, endTarget)\n}\n\n// Define optional methods - these are added in by the ToolbarButton constructor\nconst options = {init}\nconst H1 = new _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__.default( 'block', 'H1', 'Heading 1', _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__.h1, click, options )\nconst H2 = new _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__.default( 'block', 'H2', 'Heading 2', _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__.h2, click, options )\nconst P  = new _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__.default( 'block', 'P',  'Paragraph', _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__.p,  click, options )\nconst OL = new _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__.default( 'list',  'OL', 'Ordered list',   _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__.ol, click, options)\nconst UL = new _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__.default( 'list',  'UL', 'Unordered list', _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__.ul, click, options)\n\nconst buttons = [ H1, H2, P, OL, UL ]\n\n//# sourceURL=webpack://AJE/./src/js/blocks.js?");

/***/ }),

/***/ "./src/js/helpers.js":
/*!***************************!*\
  !*** ./src/js/helpers.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arraysEqual\": () => (/* binding */ arraysEqual),\n/* harmony export */   \"arraySubset\": () => (/* binding */ arraySubset),\n/* harmony export */   \"insertAfter\": () => (/* binding */ insertAfter),\n/* harmony export */   \"isInline\": () => (/* binding */ isInline),\n/* harmony export */   \"isList\": () => (/* binding */ isList),\n/* harmony export */   \"isBlock\": () => (/* binding */ isBlock),\n/* harmony export */   \"isCustom\": () => (/* binding */ isCustom),\n/* harmony export */   \"getParentBlockNode\": () => (/* binding */ getParentBlockNode),\n/* harmony export */   \"getTopParentNode\": () => (/* binding */ getTopParentNode),\n/* harmony export */   \"cleanForSaving\": () => (/* binding */ cleanForSaving),\n/* harmony export */   \"getRange\": () => (/* binding */ getRange),\n/* harmony export */   \"setCursorToTargetNode\": () => (/* binding */ setCursorToTargetNode),\n/* harmony export */   \"setCursor\": () => (/* binding */ setCursor),\n/* harmony export */   \"START_MARKER\": () => (/* binding */ START_MARKER),\n/* harmony export */   \"END_MARKER\": () => (/* binding */ END_MARKER),\n/* harmony export */   \"blockEndMarker\": () => (/* binding */ blockEndMarker),\n/* harmony export */   \"addStartMarker\": () => (/* binding */ addStartMarker),\n/* harmony export */   \"addEndMarker\": () => (/* binding */ addEndMarker),\n/* harmony export */   \"getStartNode\": () => (/* binding */ getStartNode),\n/* harmony export */   \"getEndNode\": () => (/* binding */ getEndNode),\n/* harmony export */   \"resetSelection\": () => (/* binding */ resetSelection),\n/* harmony export */   \"debounce\": () => (/* binding */ debounce),\n/* harmony export */   \"appliedFormats\": () => (/* binding */ appliedFormats)\n/* harmony export */ });\n// -----------------------------------------------------------------------------\n// @section Arrays\n// -----------------------------------------------------------------------------\n\nconst arraysEqual = function( a, b ){\n    if ( a.length != 0 && b.length!= 0 && a.length != b.length ){\n        return false\n    }\n    return a.every( (item, index) => b[index] == item )\n}\n\nconst arraySubset = function( a, b ){\n    return a.every( (item, index) => b[index] == item )\n}\n\n\n// -----------------------------------------------------------------------------\n// @section Dom manipulation\n// -----------------------------------------------------------------------------\n\nconst insertAfter = function(newNode, existingNode) {\n    return existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling);\n}\n\nconst isInline = function( node ){\n    if ( node.tagName == undefined ){\n        return false\n    }\n    const tags = ['B','I','U']\n    return tags.includes(node.tagName)\n}\n\nconst isList = function( node ){\n    if ( node.tagName == undefined ){\n        return false\n    }\n    const tags = ['UL','OL','LI']\n    return tags.includes(node.tagName)\n}\n\n// @todo These need to be dynamically registered\n// Note the addition of LI in both sets and DIV in blocks\n\nconst isBlock = function( node ){\n    if ( node.tagName == undefined ){\n        return false\n    }\n    // const tags = ['DIV','H1','H2','H3','H4','H5','H6','P','LI']\n    const tags = ['DIV','H1','H2','P','LI']\n    return tags.includes(node.tagName)\n}\n\nconst isCustom = function( node ){\n    // @todo Check this is the correct test - i.e. quotes required\n    // console.warn(`Checking isCustom node.contenteditable =[${node.contenteditable}]`)\n    return node.contenteditable === 'false'\n }\n\n const getParentBlockNode = function(node){\n    // Keep going up the tree while the node is not a block node\n    // (the editor is a block node - a DIV)\n    while ( isBlock(node)==false ){\n        node = node.parentNode\n    }\n    return node\n}\n\n\n/**\n * Get the top parent node for a child node \n * @param {*} node A child node\n * @param {*} stopNode A parent node defining when to stop going back up the dom tree\n * @returns {*} first node below the stop node (if there is one) otherwise the stopNode\n */\nconst getTopParentNode = function( node, stopNode ){\n    let saved = node\n    while ( node != stopNode ){\n        saved = node\n        node = node.parentNode\n    }\n    return saved\n}\n\nconst cleanForSaving = function( node, buttons ){\n    // if ( node.nodeType === 1 && node.tagName == 'BLOCKQUOTE' ){\n    //     debugger\n    // }\n    // Trim text nodes with CR's\n    if ( node.nodeType === 3 ){\n        if ( node.textContent.includes('\\n') ){\n            node.textContent = node.textContent.trim()\n        }\n        return\n    }\n    // Now strip anything other than a normal node\n    if ( node.nodeType !== 1 ){\n        node.remove()\n        return\n    }\n    // Remove anything we don't recognise\n    if ( isBlock(node) === false && \n         isList(node) === false && \n         isInline(node) === false && \n         isCustom(node) === false ){\n        node.remove()\n        return\n    }\n    // Handle custom nodes\n    if ( buttons.length>0 && isCustom(node)  ){\n        // Does it require cleaning?\n        const match = buttons.find( \n            button => button.tag.toUpperCase()===node.tagName\n        )\n        if ( match && \"clean\" in match ){\n            const newNode = match.clean(node)\n            node.parentNode.replaceChild(newNode, node)\n        }\n        return\n    } \n    // Handle child nodes\n    node.childNodes.forEach( child => {\n        cleanForSaving( child, buttons )\n    })\n    return \n}\n\n\n// -----------------------------------------------------------------------------\n// @section Selection and keyboard methods\n// -----------------------------------------------------------------------------\n\nconst getRange = function(){\n    // The selector is looking for a class used with modals so selections\n    // are ignored when modals are active\n    if ( document.querySelector('.no-range-if-shown.show') === null ){\n        let sel = window.getSelection()\n        if ( sel.rangeCount==1 ){\n            let range =  sel.getRangeAt(0)\n            // First parent node that is a block tag\n            range.blockParent = getParentBlockNode(range.commonAncestorContainer)\n            // First parent node\n            range.rootNode = range.commonAncestorContainer\n            if ( range.commonAncestorContainer.nodeType === 3 ) {\n                range.rootNode = range.commonAncestorContainer.parentNode\n            } \n            return range\n        }\n    }\n    return false\n}\n\nconst setCursorToTargetNode = function(editor, target){\n    // If the target node isn't the editor make it the one before\n    if ( target != editor ){\n        target = target.previousElementSibling\n    }\n    // Look for the last child - cannot use lastElementChild because that ignores text nodes\n    while ( target.lastChild != null ){\n        target = target.lastChild\n    }\n    // If found and it is a text node set the cursor to the end\n    if ( target.nodeType === 3 ){\n        console.warn('Found target',target)\n        console.warn('Found length',target.textContent.length)\n        setCursor(target,target.textContent.length)\n    // Else set to the start\n    } else {\n        setCursor(target,0)\n    }\n}\n\n\nconst setCursor = function( node, offset ){\n    const range = document.createRange()\n    const selection = window.getSelection()\n    // Check the offset is in range\n    // if ( offset > node.textContent.length - 1 ){\n    if ( offset > node.textContent.length ){\n        offset = 0\n    }\n    range.setStart(node, offset)\n    range.collapse(true)\n    selection.removeAllRanges()\n    selection.addRange(range)\n    return range\n}\n\n// Mark text with \"unusual\" none-keyboard characters\n// https://www.w3schools.com/charsets/ref_utf_math.asp\n// const START_MARKER = '&isin;' // Is in (i.e. from here)\n// const END_MARKER = '&ni;'     // Not in (i.e. from here)\n\nconst START_MARKER = '§'\nconst END_MARKER = '±'\nconst END_MARKER_CLASS = 'end-marker'\n\n\nconst blockEndMarker = function(){\n    const span = document.createElement('span')\n    span.classList.add(END_MARKER_CLASS)\n    span.contentEditable = 'false'\n    span.innerHTML = END_MARKER\n    return span\n}\n\nlet startNode = null\nlet startOffset = 0\nlet endNode = null\nlet endOffset = 0\n\n\n\nconst addStartMarker = function( text, offset ){\n    return text.substring(0,offset) + \n            START_MARKER + \n            text.substring(offset)\n}\n\nconst addEndMarker = function( text, offset ){\n    return text.substring(0,offset-1) + \n           END_MARKER +\n           text.substring(offset)\n}\n\nconst getStartNode = function(parent){\n    return findMarkerNode( parent, START_MARKER)\n}\n\nconst getEndNode = function(parent){\n    return findMarkerNode( parent, END_MARKER)\n}\n\n/**\n * Find a text node containing the given marker text\n * @param node parent The node to end searching from\n * @param node marker The marker text to locate\n * @returns {node,offset}|false \n */\nfunction findMarkerNode( parent, marker ){\n    for( let i=0; i<parent.childNodes.length; i++ ){\n        const child = parent.childNodes[i]\n        if ( child.nodeType === 1 ){\n            if ( findMarkerNode( child, marker ) ){\n                return true\n            }\n        } else if ( child.nodeType === 3 ){\n            const index = child.textContent.indexOf(marker)\n            if ( index != -1 ){\n                console.log('Found node with marker', marker)\n                child.textContent = child.textContent.replace(marker,'')\n                if ( marker == START_MARKER ){\n                    startNode = child\n                    startOffset = index\n                } else {\n                    endNode = child\n                    endOffset = index\n                }\n                return true\n            }\n        }\n    }\n    return false\n}\n\nconst resetSelection = function( editorNode ){\n    if ( getStartNode( editorNode ) && getEndNode( editorNode ) ){\n        console.log('startNode',startNode)\n        console.log('endNode',endNode)\n        const range = document.createRange()\n        const selection = window.getSelection()\n        range.setStart(startNode, startOffset)\n        if ( startNode==endNode && startOffset==endOffset){\n            range.collapse(true)\n        } else {\n            range.setEnd(endNode, endOffset)\n        }\n        selection.removeAllRanges()\n        selection.addRange(range)\n        return range\n    }\n    return false\n}\n\nconst debounce = function(fn, delay) {\n    let timeOutId\n    return function(...args) {\n        // Clear previous timeout if not expired\n        if( timeOutId ) {\n            clearTimeout(timeOutId)\n        }\n        // Set new timeout\n        timeOutId = setTimeout(() => {\n            fn(...args)\n        }, delay)\n    }\n}\n\nconst appliedFormats = function( node, editorNode, rootNode , formatType){\n    let formats = []\n    // Collect tags of appropriate type\n    while ( node != editorNode && node != null ){\n        if ( node.nodeType === 1 ){   \n            if ( formatType == '' ){\n                formats.unshift( node.tagName )\n            } else if ( formatType == 'inline' ){\n                if ( isInline(node) ){\n                    formats.unshift( node.tagName )\n                }\n            } else if ( formatType == 'block' ){\n                if ( isBlock(node)){\n                    formats.unshift( node.tagName )\n                }\n            } else if ( formatType == 'enter' ){\n                formats.unshift( node )\n                if ( node == rootNode ){\n                    break\n                }\n            }\n        }\n        node = node.parentNode\n    }\n    //console.log(`Applied formats = [${formats.join(' => ')}]`)\n    return formats\n}\n\n\n\n\n//# sourceURL=webpack://AJE/./src/js/helpers.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Editor\": () => (/* binding */ Editor),\n/* harmony export */   \"Mentions\": () => (/* binding */ Mentions),\n/* harmony export */   \"Links\": () => (/* binding */ Links)\n/* harmony export */ });\n// https://stackoverflow.com/questions/42719908/use-webpack-to-bundle-several-es6-classes-into-one-file-for-import-in-a-script-t\n\nconst Editor = __webpack_require__(/*! ./Editor.js */ \"./src/js/Editor.js\").default\nconst Mentions = __webpack_require__(/*! ./plugins/mentions.js */ \"./src/js/plugins/mentions.js\")\nconst Links = __webpack_require__(/*! ./plugins/links.js */ \"./src/js/plugins/links.js\")\n\n\n\n//# sourceURL=webpack://AJE/./src/js/index.js?");

/***/ }),

/***/ "./src/js/inline.js":
/*!**************************!*\
  !*** ./src/js/inline.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buttons\": () => (/* binding */ buttons)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/js/helpers.js\");\n/* harmony import */ var _phase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./phase.js */ \"./src/js/phase.js\");\n/* harmony import */ var _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/icons.js */ \"./src/js/plugins/icons.js\");\n/* harmony import */ var _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/ToolbarButton.js */ \"./src/js/plugins/ToolbarButton.js\");\n\n\n\n\n\nlet editorNode\nlet formatAction = ''\nlet newFormat = ''\nlet categorisedTextNodes = []\nlet range\nlet fragmentNode\n\n\nfunction categoriseProtectedNode( node ){\n    const formats = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.appliedFormats(node, editorNode, range.rootNode, 'inline' )\n    categorisedTextNodes.push({\n        node: node.cloneNode(true),\n        text:'',\n        formats\n    })\n}\n\nfunction categoriseTextNode( node ){\n    console.log( `Categorise text node [${node.textContent}]`)\n    // Get the [0] pre, [1]selected and [2]post text\n    const texts = getTextNodes( node )\n    // console.log(`texts = [${texts.join(', ')}]`)\n    let formats = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.appliedFormats(node, editorNode, range.rootNode, 'inline' )\n    // console.log(`current formats = [${formats.join(' ')}]`)\n    // Pre text\n    if ( texts[0] ){\n        console.log(`Adding pre text [${texts[0]}]`)\n        categorisedTextNodes.push({\n            node: false,\n            text: texts[0],\n            formats\n        })\n    }\n    // Selected text\n    if ( texts[1] ){\n        let newFormats = formats.slice()\n        if ( formatAction == 'apply'  ){\n            if ( newFormats.includes(newFormat) == false ){\n                // console.log( `Adding new format [${newFormat}] in phase [${Phase.get()}]`)\n                newFormats.push(newFormat)\n            }\n        } else if ( formatAction == 'remove' ){\n            if ( newFormat == 'CLEAR' ){\n                newFormats = []\n            } else {\n                newFormats = formats.filter( format => format != newFormat )\n            }\n        }\n        // console.log(`Adding selected text [${texts[1]}]`)\n        categorisedTextNodes.push({\n            node:false,\n            text:texts[1],\n            formats: newFormats\n        })\n    }\n    // Post text\n    if ( texts[2] ){\n        // console.log(`Adding post text [${texts[2]}]`)\n        categorisedTextNodes.push({\n            node:false,\n            text:texts[2],\n            formats\n        })\n    }\n}\n\nfunction parseInlineNode( node ){\n    let n = false\n    let t = false\n    _phase_js__WEBPACK_IMPORTED_MODULE_1__.set( node )\n    // Parent node\n    if ( node.nodeType === 1 ){\n        console.log(`Parsing parent node`, node.outerHTML )\n        if ( node.getAttribute('contenteditable') == 'false' ){\n            categoriseProtectedNode( node )\n        } else {\n            node.childNodes.forEach( child => {\n                parseInlineNode( child )\n            })\n        }\n    } else if ( node.nodeType === 3 ){\n        categoriseTextNode( node )\n    }\n}\n\nfunction processCategorisedNodes(){\n    // Node list is as follows\n    // [i] = {node, text, formats, sorted}\n    // where node present for custom nodes like actions\n    // and sorted is the list of formats ordered\n    //\n    // Combine nodes with same formats or spaces (and no formats)\n    for( let i=1; i<categorisedTextNodes.length; i++ ){\n        let current = categorisedTextNodes[i]\n        let previous = categorisedTextNodes[i-1]\n        if ( previous.node == false && current.node == false ){\n            if ( previous.sorted == current.sorted /* || current.text == ' ' */) {\n                // Combine texts in current node\n                current.text = previous.text + current.text\n                // Bring formats forwad in case current text was a space (with no formats)\n                current.formats = previous.formats\n                // Clear previous text\n                previous.text = ''\n            }\n        }\n    }\n    // Join remaining nodes with required formatting\n    categorisedTextNodes.forEach( node => {\n        // Just add custom nodes\n        if ( node.node ){\n            fragmentNode.appendChild(node.node)\n        // If have any text then add with formats\n        } else if ( node.text != '' ){\n            let n\n            // Build up format nodes\n            node.formats.forEach( format => {\n                const temp = document.createElement(format)\n                if ( n ){\n                    n = n.appendChild(temp)\n                } else {\n                    n = temp\n                }\n            })\n            // Add the text node\n            const t = document.createTextNode(node.text)\n            if ( n ){\n                n.appendChild(t)\n            } else {\n                n = t\n            }\n            // Come back up the tree\n            while ( n.parentNode !== null ){\n                n = n.parentNode\n            }    \n            // Add to the node to the fragment            \n            fragmentNode.appendChild(n)\n        }\n    })\n}\n\nfunction getTextNodes( node ){\n    // Before, during and after texts\n    let text\n    let texts = []\n    if ( _phase_js__WEBPACK_IMPORTED_MODULE_1__.both() ) {\n        texts.push( node.textContent.substring(0,range.startOffset) )\n        text = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.START_MARKER + node.textContent.substring(range.startOffset,range.endOffset) + _helpers_js__WEBPACK_IMPORTED_MODULE_0__.END_MARKER\n        texts.push( text )\n        // endOffset = text.length - 2\n        texts.push( node.textContent.substring(range.endOffset) )\n    } else if ( _phase_js__WEBPACK_IMPORTED_MODULE_1__.first() ){\n        texts.push( node.textContent.substring(0,range.startOffset) )\n        texts.push( _helpers_js__WEBPACK_IMPORTED_MODULE_0__.START_MARKER + node.textContent.substring(range.startOffset))\n        texts.push( '' )\n    } else if ( _phase_js__WEBPACK_IMPORTED_MODULE_1__.last() ){\n        texts.push( '' )\n        text = node.textContent.substring(0,range.endOffset) + _helpers_js__WEBPACK_IMPORTED_MODULE_0__.END_MARKER\n        texts.push( text )\n        // endOffset = range.endOffset\n        texts.push( node.textContent.substring(range.endOffset) )\n    } else if ( _phase_js__WEBPACK_IMPORTED_MODULE_1__.during() ){\n        texts.push( '' )\n        texts.push( node.textContent )\n        texts.push( '' )   \n    } else if ( _phase_js__WEBPACK_IMPORTED_MODULE_1__.pre() ){\n        texts.push( node.textContent )\n        texts.push( '' )\n        texts.push( '' )\n    } else if ( _phase_js__WEBPACK_IMPORTED_MODULE_1__.post() ){\n        texts.push( '' )\n        texts.push( '' )\n        texts.push( node.textContent )\n    }\n    // // Check for trailing spaces\n    // if ( texts[2] == ' ' ){\n    //     texts[2] = ''\n    //     texts[1] += ' '\n    // }\n    return texts\n}\n\nfunction logCategorisedNodes(debug){\n    let c = []\n    categorisedTextNodes.forEach( n => {\n        // Sort the formats - for later comparison\n        n.formats.sort()\n        n.sorted = n.formats.join(' ')\n        // List the nodes\n        let f = n.formats.join(' ')\n        c.push( {\n            html: n.node ? n.node.outerHTML : '',\n            text: n.text,\n            formats: f,\n            sorted: n.sorted\n        })\n    })\n    if ( debug ){\n        console.table(c)\n    }\n}\n\nconst init = function(editor){\n    if ( editorNode == undefined ){\n        editorNode = editor\n    }\n}\n\nconst disabled = function(range){\n    if ( range === false ){\n        this.element.disabled = true\n    } else if ( this.tag == 'CLEAR' ){\n        this.element.disabled = false\n    // Inline formatting only applies to single blocks\n    } else {\n        this.element.disabled = range.startContainer != range.endContainer\n    }\n}\n\nconst click = function( rng ){\n    range = rng\n    formatAction = 'apply'\n    if ( this.tag == 'CLEAR' || this.element.classList.contains('active') ){\n        formatAction = 'remove'\n    }\n    // console.log('Format action', formatAction)\n    newFormat = this.tag\n    range.rootNode = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.getTopParentNode( range.rootNode, editorNode )\n    // The root node must be a block node (including list item LI) or an inline node\n    if ( _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isBlock(range.rootNode) == false &&\n         _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInline(range.rootNode) == false ){\n       return\n    }\n    // Look for inline parent nodes that only have one child\n    // to ensure can clear all formats from selected text\n    while ( _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInline(range.rootNode.parentNode) && \n            range.rootNode.parentNode.childNodes.length === 1){\n        range.rootNode = range.rootNode.parentNode\n    }\n    // Reset fragment and categorised nodes\n    fragmentNode = document.createElement('DIV')\n    categorisedTextNodes = []\n    // Init phase for list formatting\n    _phase_js__WEBPACK_IMPORTED_MODULE_1__.init(range, false)\n    // Parse\n    console.log('%cStarting inline parsing ...', 'background-color:red; color:white; padding:0.5rem;')\n    parseInlineNode( range.rootNode )\n    // true = debugging\n    logCategorisedNodes(true)\n    // Process saved nodes\n    processCategorisedNodes()\n    // Check for text only content being applied to the editor,\n    // in which case wrap with a paragraph\n    if ( range.rootNode == editorNode && \n         fragmentNode.childNodes.length == 1 && fragmentNode.childNodes[0].nodeType === 3 ){\n        const paragraph = document.createElement('P')\n        paragraph.innerHTML = fragmentNode.innerHTML.trim()\n        fragmentNode.innerHTML = paragraph.outerHTML\n    }\n    // Write out changes\n    if ( _helpers_js__WEBPACK_IMPORTED_MODULE_0__.isInline(range.rootNode) ){\n        range.rootNode.outerHTML = fragmentNode.innerHTML\n    } else {\n        range.rootNode.innerHTML = fragmentNode.innerHTML\n    }\n    // Reset the selection, returning the new range\n    return _helpers_js__WEBPACK_IMPORTED_MODULE_0__.resetSelection(editorNode)\n}\n\n\n\nconst options = {init,disabled}\nconst B = new _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__.default( 'inline', 'B', 'Bold', _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__.b, click, options)\nconst I = new _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__.default( 'inline', 'I', 'Italic', _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__.i, click, options)\nconst U = new _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__.default( 'inline', 'U',  'Underline', _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__.u, click, options)\nconst CLEAR = new _plugins_ToolbarButton_js__WEBPACK_IMPORTED_MODULE_3__.default( 'inline', 'CLEAR', 'Clear', _plugins_icons_js__WEBPACK_IMPORTED_MODULE_2__.clear, click, options)\n\nconst buttons = [ B, I, U, CLEAR ]\n\n//# sourceURL=webpack://AJE/./src/js/inline.js?");

/***/ }),

/***/ "./src/js/phase.js":
/*!*************************!*\
  !*** ./src/js/phase.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"get\": () => (/* binding */ get),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"pre\": () => (/* binding */ pre),\n/* harmony export */   \"first\": () => (/* binding */ first),\n/* harmony export */   \"both\": () => (/* binding */ both),\n/* harmony export */   \"last\": () => (/* binding */ last),\n/* harmony export */   \"during\": () => (/* binding */ during),\n/* harmony export */   \"post\": () => (/* binding */ post)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./src/js/helpers.js\");\n\n\n\nlet startContainer\nlet endContainer\nlet phase = ''\n\nconst init = function(range, block){\n    startContainer = range.startContainer \n    endContainer = range.endContainer \n    // For block formatting start with block (not text nodes)\n    if ( block ){\n        startContainer = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.getParentBlockNode(startContainer)\n        endContainer = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.getParentBlockNode(endContainer)\n    }\n    phase = 'pre'\n}\n\nconst get = function(){\n    return phase\n}\n\n// @todo This needs to move into helpes but need to pass in the range \n// or start and end containers (which could lose the block_or_inline param)\n// Would also need to pass in the current phase and return the new phase\nconst set = function( node ){\n    // Adjust phase\n    if ( node == startContainer ){\n        phase = 'first'\n        if ( node == endContainer ){\n            phase = 'both'\n        }\n    } else if ( node == endContainer ){\n        phase = 'last'\n    } else if ( phase == 'first') {\n        phase = 'during'\n    } else if ( phase == 'both' || phase == 'last' ){\n        phase = 'post-first'\n    } else if ( phase == 'post-first' ){\n        phase = 'post'\n    }\n    console.log('New phase=',phase)\n}\n\nconst pre = function(){\n    return phase == 'pre'\n}\n\nconst first = function(){\n    return phase == 'first' || phase == 'both' \n}\n\nconst both = function(){\n    return phase == 'both' \n}\n\nconst last = function(){\n    return phase == 'last'\n}\n\nconst during = function(){\n    return phase == 'during' || phase == 'first' || phase == 'last' || phase == 'both' \n}\n\nconst post = function(){\n    return phase == 'post-first' || phase == 'post' \n}\n\n\n//# sourceURL=webpack://AJE/./src/js/phase.js?");

/***/ }),

/***/ "./src/js/plugins/ToolbarButton.js":
/*!*****************************************!*\
  !*** ./src/js/plugins/ToolbarButton.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass ToolbarButton {\n\n    constructor( type, tag, label, icon, click, options ){\n        this.type = type\n        this.tag = tag\n        this.label = label\n        this.icon = icon\n        this.click = click\n        this.disabled = this.disabled\n        this.element = null // Populated by editor\n        // Optional parameters\n        if ( options != undefined ){\n            if ( options.init != undefined ){\n                this.init = options.init\n            }\n            if ( options.disabled != undefined ){\n                this.disabled = options.disabled\n            }\n            if ( options.shortcut != undefined ){\n                this.shortcut = options.shortcut\n            }\n            if ( options.eventHandlers != undefined ){\n                this.eventHandlers = options.eventHandlers\n            }\n            if ( options.clean != undefined ){\n                this.clean = options.clean\n            }\n        }\n    }\n\n    // Default disabled method\n    disabled(range){\n        if ( range === false ){\n            this.element.disabled = true\n            this.element.classList.remove('active')\n        } else {\n            this.element.disabled = false\n        }\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ToolbarButton);\n\n//# sourceURL=webpack://AJE/./src/js/plugins/ToolbarButton.js?");

/***/ }),

/***/ "./src/js/plugins/buffer.js":
/*!**********************************!*\
  !*** ./src/js/plugins/buffer.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"update\": () => (/* binding */ update),\n/* harmony export */   \"buttons\": () => (/* binding */ buttons)\n/* harmony export */ });\n/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icons.js */ \"./src/js/plugins/icons.js\");\n/* harmony import */ var _ToolbarButton_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ToolbarButton.js */ \"./src/js/plugins/ToolbarButton.js\");\n\n\n\nlet size = 10\nlet bufferIndex = 0\nlet target = null\nlet buffer = []\n\nfunction setButtonState(){\n    UNDO.disabled()\n    REDO.disabled()\n}\n\nfunction undo(){\n    let status = false\n    if ( bufferIndex > 0 ){\n        bufferIndex --\n        target.innerHTML = buffer[bufferIndex]\n        status = true\n    }\n    setButtonState()\n    return status\n}\n\nfunction redo(){\n    if ( bufferIndex + 1 < buffer.length ){\n        bufferIndex ++\n        target.innerHTML = buffer[bufferIndex]\n        return true\n    }\n    setButtonState()\n    return false\n}\n\nconst undoDisabled = function(){\n    this.element.disabled = buffer.length==0 || bufferIndex==0\n}\n\nconst redoDisabled = function(){\n    this.element.disabled = bufferIndex >= buffer.length - 1\n}\n\n\n// -----------------------------------------------------------------------------\n// @section Exports\n// -----------------------------------------------------------------------------\n\nconst init = function( options ){\n    size = options.size\n    target = options.target\n    buffer = [target.innerHTML]\n}\n\nconst update = function(){\n    if ( buffer.length > size ){\n        // Remove first element\n        buffer.shift()\n    }\n    // Check buffer index in case need to reset buffer when the user had\n    // undone and then made new changes\n    if ( (bufferIndex + 1) < buffer.length ){\n        const items = buffer.length - (bufferIndex + 1)\n        for( let i=0; i<items; i++){\n            buffer.pop()\n        }\n    }\n    // Add the new one\n    buffer.push(target.innerHTML)\n    bufferIndex = buffer.length - 1\n    console.log('buffer', buffer)\n    // Update buttons\n    setButtonState()\n}\n\nconst uOptions = {disabled:undoDisabled}\nconst rOptions = {disabled:redoDisabled}\nconst UNDO = new _ToolbarButton_js__WEBPACK_IMPORTED_MODULE_1__.default('buffer','UNDO','Undo', _icons_js__WEBPACK_IMPORTED_MODULE_0__.undo, undo, uOptions)\nconst REDO = new _ToolbarButton_js__WEBPACK_IMPORTED_MODULE_1__.default('buffer','REDO','Redo', _icons_js__WEBPACK_IMPORTED_MODULE_0__.redo, redo, rOptions)\n\nconst buttons = [UNDO, REDO]\n\n\n\n\n//# sourceURL=webpack://AJE/./src/js/plugins/buffer.js?");

/***/ }),

/***/ "./src/js/plugins/icons.js":
/*!*********************************!*\
  !*** ./src/js/plugins/icons.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"h1\": () => (/* binding */ h1),\n/* harmony export */   \"h2\": () => (/* binding */ h2),\n/* harmony export */   \"p\": () => (/* binding */ p),\n/* harmony export */   \"ol\": () => (/* binding */ ol),\n/* harmony export */   \"ul\": () => (/* binding */ ul),\n/* harmony export */   \"b\": () => (/* binding */ b),\n/* harmony export */   \"i\": () => (/* binding */ i),\n/* harmony export */   \"u\": () => (/* binding */ u),\n/* harmony export */   \"clear\": () => (/* binding */ clear),\n/* harmony export */   \"undo\": () => (/* binding */ undo),\n/* harmony export */   \"redo\": () => (/* binding */ redo),\n/* harmony export */   \"person\": () => (/* binding */ person),\n/* harmony export */   \"action\": () => (/* binding */ action),\n/* harmony export */   \"actionClosedIncomplete\": () => (/* binding */ actionClosedIncomplete),\n/* harmony export */   \"actionClosedComplete\": () => (/* binding */ actionClosedComplete),\n/* harmony export */   \"agreement\": () => (/* binding */ agreement),\n/* harmony export */   \"link\": () => (/* binding */ link),\n/* harmony export */   \"cross\": () => (/* binding */ cross),\n/* harmony export */   \"view\": () => (/* binding */ view),\n/* harmony export */   \"edit\": () => (/* binding */ edit),\n/* harmony export */   \"dots\": () => (/* binding */ dots),\n/* harmony export */   \"arrowRight\": () => (/* binding */ arrowRight),\n/* harmony export */   \"dashboardLarge\": () => (/* binding */ dashboardLarge),\n/* harmony export */   \"backArrowLarge\": () => (/* binding */ backArrowLarge)\n/* harmony export */ });\n/**\n * \n * This file includes source software from Bootstrap (https://icons.getbootstrap.com)\n * is MIT licenced which is reproduced here in full.\n * \n * The MIT License (MIT)\n *\n * Copyright (c) 2011-2018 Twitter, Inc.\n * Copyright (c) 2011-2018 The Bootstrap Authors\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n * Usage:\n * \n * These icons are form version 1.4.0\n * To add or modify icons, find the icon using the link above and then copy the path component of the svg source\n * \n */\n\n\n\nfunction icon( path, options ){\n    let width  = 16\n    let height = 16\n    let scale  = 1\n    if ( options != undefined ){\n        if ( options.scale ){\n            scale = options.scale\n            width = width * scale\n            height = height * scale\n        }\n    }\n    return `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\" viewBox=\"0 0 ${width} ${height}\" fill=\"currentColor\">\n                <g transform=\"scale(${scale})\">${path}</g>\n            </svg>`\n}\n\nconst h1 = icon( `\n    <path d=\"M8.637 13V3.669H7.379V7.62H2.758V3.67H1.5V13h1.258V8.728h4.62V13h1.259zm5.329 0V3.669h-1.244L10.5 5.316v1.265l2.16-1.565h.062V13h1.244z\"/>\n`)\nconst h2 = icon( `\n    <path d=\"M7.638 13V3.669H6.38V7.62H1.759V3.67H.5V13h1.258V8.728h4.62V13h1.259zm3.022-6.733v-.048c0-.889.63-1.668 1.716-1.668.957 0 1.675.608 1.675 1.572 0 .855-.554 1.504-1.067 2.085l-3.513 3.999V13H15.5v-1.094h-4.245v-.075l2.481-2.844c.875-.998 1.586-1.784 1.586-2.953 0-1.463-1.155-2.556-2.919-2.556-1.941 0-2.966 1.326-2.966 2.74v.049h1.223z\"/>\n`)\nconst p = icon( `\n    <path d=\"M10.5 15a.5.5 0 0 1-.5-.5V2H9v12.5a.5.5 0 0 1-1 0V9H7a4 4 0 1 1 0-8h5.5a.5.5 0 0 1 0 1H11v12.5a.5.5 0 0 1-.5.5z\"/>\n`)\nconst ol = icon( `\n    <path fill-rule=\"evenodd\" d=\"M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5z\"/>\n    <path d=\"M1.713 11.865v-.474H2c.217 0 .363-.137.363-.317 0-.185-.158-.31-.361-.31-.223 0-.367.152-.373.31h-.59c.016-.467.373-.787.986-.787.588-.002.954.291.957.703a.595.595 0 0 1-.492.594v.033a.615.615 0 0 1 .569.631c.003.533-.502.8-1.051.8-.656 0-1-.37-1.008-.794h.582c.008.178.186.306.422.309.254 0 .424-.145.422-.35-.002-.195-.155-.348-.414-.348h-.3zm-.004-4.699h-.604v-.035c0-.408.295-.844.958-.844.583 0 .96.326.96.756 0 .389-.257.617-.476.848l-.537.572v.03h1.054V9H1.143v-.395l.957-.99c.138-.142.293-.304.293-.508 0-.18-.147-.32-.342-.32a.33.33 0 0 0-.342.338v.041zM2.564 5h-.635V2.924h-.031l-.598.42v-.567l.629-.443h.635V5z\"/>\n`)\nconst ul = icon( `\n    <path fill-rule=\"evenodd\" d=\"M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2z\"/>\n`)\nconst b = icon( `\n    <path d=\"M8.21 13c2.106 0 3.412-1.087 3.412-2.823 0-1.306-.984-2.283-2.324-2.386v-.055a2.176 2.176 0 0 0 1.852-2.14c0-1.51-1.162-2.46-3.014-2.46H3.843V13H8.21zM5.908 4.674h1.696c.963 0 1.517.451 1.517 1.244 0 .834-.629 1.32-1.73 1.32H5.908V4.673zm0 6.788V8.598h1.73c1.217 0 1.88.492 1.88 1.415 0 .943-.643 1.449-1.832 1.449H5.907z\"/>\n`)\nconst i = icon( `\n    <path d=\"M7.991 11.674 9.53 4.455c.123-.595.246-.71 1.347-.807l.11-.52H7.211l-.11.52c1.06.096 1.128.212 1.005.807L6.57 11.674c-.123.595-.246.71-1.346.806l-.11.52h3.774l.11-.52c-1.06-.095-1.129-.211-1.006-.806z\"/>\n`)\nconst u  = icon( `\n    <path d=\"M5.313 3.136h-1.23V9.54c0 2.105 1.47 3.623 3.917 3.623s3.917-1.518 3.917-3.623V3.136h-1.23v6.323c0 1.49-.978 2.57-2.687 2.57-1.709 0-2.687-1.08-2.687-2.57V3.136zM12.5 15h-9v-1h9v1z\"/>\n`)\nconst clear = icon( `\n    <path d=\"M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm2.121.707a1 1 0 0 0-1.414 0L4.16 7.547l5.293 5.293 4.633-4.633a1 1 0 0 0 0-1.414l-3.879-3.879zM8.746 13.547 3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z\"/>\n`)\nconst undo = icon( `\n    <path d=\"M6.598 5.013a.144.144 0 0 1 .202.134V6.3a.5.5 0 0 0 .5.5c.667 0 2.013.005 3.3.822.984.624 1.99 1.76 2.595 3.876-1.02-.983-2.185-1.516-3.205-1.799a8.74 8.74 0 0 0-1.921-.306 7.404 7.404 0 0 0-.798.008h-.013l-.005.001h-.001L7.3 9.9l-.05-.498a.5.5 0 0 0-.45.498v1.153c0 .108-.11.176-.202.134L2.614 8.254a.503.503 0 0 0-.042-.028.147.147 0 0 1 0-.252.499.499 0 0 0 .042-.028l3.984-2.933zM7.8 10.386c.068 0 .143.003.223.006.434.02 1.034.086 1.7.271 1.326.368 2.896 1.202 3.94 3.08a.5.5 0 0 0 .933-.305c-.464-3.71-1.886-5.662-3.46-6.66-1.245-.79-2.527-.942-3.336-.971v-.66a1.144 1.144 0 0 0-1.767-.96l-3.994 2.94a1.147 1.147 0 0 0 0 1.946l3.994 2.94a1.144 1.144 0 0 0 1.767-.96v-.667z\"/>\n`)\nconst redo = icon( `\n    <path d=\"M6.598 5.013a.144.144 0 0 1 .202.134V6.3a.5.5 0 0 0 .5.5c.667 0 2.013.005 3.3.822.984.624 1.99 1.76 2.595 3.876-1.02-.983-2.185-1.516-3.205-1.799a8.74 8.74 0 0 0-1.921-.306 7.404 7.404 0 0 0-.798.008h-.013l-.005.001h-.001L7.3 9.9l-.05-.498a.5.5 0 0 0-.45.498v1.153c0 .108-.11.176-.202.134L2.614 8.254a.503.503 0 0 0-.042-.028.147.147 0 0 1 0-.252.499.499 0 0 0 .042-.028l3.984-2.933zM7.8 10.386c.068 0 .143.003.223.006.434.02 1.034.086 1.7.271 1.326.368 2.896 1.202 3.94 3.08a.5.5 0 0 0 .933-.305c-.464-3.71-1.886-5.662-3.46-6.66-1.245-.79-2.527-.942-3.336-.971v-.66a1.144 1.144 0 0 0-1.767-.96l-3.994 2.94a1.147 1.147 0 0 0 0 1.946l3.994 2.94a1.144 1.144 0 0 0 1.767-.96v-.667z\"/>\n`)\nconst person = icon( `\n    <path d=\"M8 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm2-3a2 2 0 1 1-4 0 2 2 0 0 1 4 0zm4 8c0 1-1 1-1 1H3s-1 0-1-1 1-4 6-4 6 3 6 4zm-1-.004c-.001-.246-.154-.986-.832-1.664C11.516 10.68 10.289 10 8 10c-2.29 0-3.516.68-4.168 1.332-.678.678-.83 1.418-.832 1.664h10z\"/>\n`)\nconst action = icon( `\n    <path d=\"M8 16a2 2 0 0 0 2-2H6a2 2 0 0 0 2 2zM8 1.918l-.797.161A4.002 4.002 0 0 0 4 6c0 .628-.134 2.197-.459 3.742-.16.767-.376 1.566-.663 2.258h10.244c-.287-.692-.502-1.49-.663-2.258C12.134 8.197 12 6.628 12 6a4.002 4.002 0 0 0-3.203-3.92L8 1.917zM14.22 12c.223.447.481.801.78 1H1c.299-.199.557-.553.78-1C2.68 10.2 3 6.88 3 6c0-2.42 1.72-4.44 4.005-4.901a1 1 0 1 1 1.99 0A5.002 5.002 0 0 1 13 6c0 .88.32 4.2 1.22 6z\"/>\n`)\nconst actionClosedIncomplete = icon( `\n    <path d=\"M5.164 14H15c-.299-.199-.557-.553-.78-1-.9-1.8-1.22-5.12-1.22-6 0-.264-.02-.523-.06-.776l-.938.938c.02.708.157 2.154.457 3.58.161.767.377 1.566.663 2.258H6.164l-1 1zm5.581-9.91a3.986 3.986 0 0 0-1.948-1.01L8 2.917l-.797.161A4.002 4.002 0 0 0 4 7c0 .628-.134 2.197-.459 3.742-.05.238-.105.479-.166.718l-1.653 1.653c.02-.037.04-.074.059-.113C2.679 11.2 3 7.88 3 7c0-2.42 1.72-4.44 4.005-4.901a1 1 0 1 1 1.99 0c.942.19 1.788.645 2.457 1.284l-.707.707zM10 15a2 2 0 1 1-4 0h4zm-9.375.625a.53.53 0 0 0 .75.75l14.75-14.75a.53.53 0 0 0-.75-.75L.625 15.625z\"/>\n`)\nconst actionClosedComplete = icon( `\n    <path d=\"M8 16a2 2 0 0 0 2-2H6a2 2 0 0 0 2 2zm.995-14.901a1 1 0 1 0-1.99 0A5.002 5.002 0 0 0 3 6c0 1.098-.5 6-2 7h14c-1.5-1-2-5.902-2-7 0-2.42-1.72-4.44-4.005-4.901z\"/>\n`)\nconst agreement = icon( `\n    <path d=\"M2.5 8a5.5 5.5 0 0 1 8.25-4.764.5.5 0 0 0 .5-.866A6.5 6.5 0 1 0 14.5 8a.5.5 0 0 0-1 0 5.5 5.5 0 1 1-11 0z\"/>\n    <path d=\"M15.354 3.354a.5.5 0 0 0-.708-.708L8 9.293 5.354 6.646a.5.5 0 1 0-.708.708l3 3a.5.5 0 0 0 .708 0l7-7z\"/>\n`)\nconst link = icon( `\n    <path d=\"M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z\"/>\n    <path d=\"M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z\"/>\n`)\nconst cross = icon( `\n    <path d=\"M1.293 1.293a1 1 0 0 1 1.414 0L8 6.586l5.293-5.293a1 1 0 1 1 1.414 1.414L9.414 8l5.293 5.293a1 1 0 0 1-1.414 1.414L8 9.414l-5.293 5.293a1 1 0 0 1-1.414-1.414L6.586 8 1.293 2.707a1 1 0 0 1 0-1.414z\"/>\n`)\nconst view = icon( `\n    <path d=\"M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z\"/>\n    <path d=\"M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z\"/>\n`)\nconst edit = icon( `\n    <path d=\"M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z\"/>\n`)\nconst dots = icon( `\n    <path d=\"M3 9.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z\"/>\n`)\nconst arrowRight = icon( `\n    <path fill-rule=\"evenodd\" d=\"M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z\"/>\n`)\nconst dashboardLarge = icon( `\n    <path d=\"M8 4a.5.5 0 0 1 .5.5V6a.5.5 0 0 1-1 0V4.5A.5.5 0 0 1 8 4zM3.732 5.732a.5.5 0 0 1 .707 0l.915.914a.5.5 0 1 1-.708.708l-.914-.915a.5.5 0 0 1 0-.707zM2 10a.5.5 0 0 1 .5-.5h1.586a.5.5 0 0 1 0 1H2.5A.5.5 0 0 1 2 10zm9.5 0a.5.5 0 0 1 .5-.5h1.5a.5.5 0 0 1 0 1H12a.5.5 0 0 1-.5-.5zm.754-4.246a.389.389 0 0 0-.527-.02L7.547 9.31a.91.91 0 1 0 1.302 1.258l3.434-4.297a.389.389 0 0 0-.029-.518z\"/>\n    <path fill-rule=\"evenodd\" d=\"M0 10a8 8 0 1 1 15.547 2.661c-.442 1.253-1.845 1.602-2.932 1.25C11.309 13.488 9.475 13 8 13c-1.474 0-3.31.488-4.615.911-1.087.352-2.49.003-2.932-1.25A7.988 7.988 0 0 1 0 10zm8-7a7 7 0 0 0-6.603 9.329c.203.575.923.876 1.68.63C4.397 12.533 6.358 12 8 12s3.604.532 4.923.96c.757.245 1.477-.056 1.68-.631A7 7 0 0 0 8 3z\"/>\n`, { scale:2 }\n)\nconst backArrowLarge = icon( `\n    <path d=\"m3.86 8.753 5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z\"/>\n`, { scale:2 })\n\n// // Alternative approach approach\n// const icons = new Map()\n// icons.set('dashboard', `\n//     <path d=\"M8 4a.5.5 0 0 1 .5.5V6a.5.5 0 0 1-1 0V4.5A.5.5 0 0 1 8 4zM3.732 5.732a.5.5 0 0 1 .707 0l.915.914a.5.5 0 1 1-.708.708l-.914-.915a.5.5 0 0 1 0-.707zM2 10a.5.5 0 0 1 .5-.5h1.586a.5.5 0 0 1 0 1H2.5A.5.5 0 0 1 2 10zm9.5 0a.5.5 0 0 1 .5-.5h1.5a.5.5 0 0 1 0 1H12a.5.5 0 0 1-.5-.5zm.754-4.246a.389.389 0 0 0-.527-.02L7.547 9.31a.91.91 0 1 0 1.302 1.258l3.434-4.297a.389.389 0 0 0-.029-.518z\"/>\n//     <path fill-rule=\"evenodd\" d=\"M0 10a8 8 0 1 1 15.547 2.661c-.442 1.253-1.845 1.602-2.932 1.25C11.309 13.488 9.475 13 8 13c-1.474 0-3.31.488-4.615.911-1.087.352-2.49.003-2.932-1.25A7.988 7.988 0 0 1 0 10zm8-7a7 7 0 0 0-6.603 9.329c.203.575.923.876 1.68.63C4.397 12.533 6.358 12 8 12s3.604.532 4.923.96c.757.245 1.477-.056 1.68-.631A7 7 0 0 0 8 3z\"/>\n// `)\n\n// export const Icon = function( name, scaled ){\n//     icon = icons.get('dashboard')\n//     let width  = 16\n//     let height = 16\n//     let scale = 1\n//     if ( scaled != undefined ){\n//         scale = scaled\n//         width = width * scale\n//         height = height * scale\n//     }\n//     return `\n//         <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\" viewBox=\"0 0 ${width} ${height}\" fill=\"currentColor\">\n//             <g transform=\"scale(${scale})\">\n//                 ${icon}\n//             </g>\n//         </svg>`\n// }\n\n\n//# sourceURL=webpack://AJE/./src/js/plugins/icons.js?");

/***/ }),

/***/ "./src/js/plugins/links.js":
/*!*********************************!*\
  !*** ./src/js/plugins/links.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buttons\": () => (/* binding */ buttons)\n/* harmony export */ });\n/* harmony import */ var _modalConfirm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modalConfirm.js */ \"./src/js/plugins/modalConfirm.js\");\n/* harmony import */ var _ToolbarButton_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ToolbarButton.js */ \"./src/js/plugins/ToolbarButton.js\");\n/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons.js */ \"./src/js/plugins/icons.js\");\n\n\n;\n\n\n\nlet editorNode\nlet dirty\nlet range\nlet panel = null\nlet linkData \n\nfunction init( target ){\n    editorNode = target\n    dirty = false\n    let links = editorNode.querySelectorAll( 'a' )\n    links.forEach( link => format( link ))\n}\n\nfunction click( rng ){\n    console.log('click link')\n    if ( range === false){\n        console.log('No range selected')\n        return\n    }\n    range = rng\n    // Get default label if range not collapsed\n    let label = ''\n    if ( range.collapsed == false && \n         range.startContainer == range.endContainer ){\n        label = range.endContainer.textContent.substring(range.startOffset, range.endOffset)  \n    }\n    linkData = {\n        id:'',\n        href:'', \n        label, \n    }\n    show(false)\n}\n\nfunction edit( domLink ){\n    // If we already have an active panel - ignore clicks on links\n    if ( panel ){\n        return\n    }\n    linkData = {\n        id: domLink.id,\n        href: domLink.href,\n        label: domLink.innerText.trim(),\n    }\n    show(true)\n}\n\nfunction show( edit ){\n    panel = document.createElement('DIV')\n    panel.id = 'link-edit'\n    panel.classList.add('edit-panel')\n    panel.innerHTML = form(linkData, edit)\n    // Initialise confirmation module and dirty data detection\n    dirty = false\n    const inputs = panel.querySelectorAll('form input')\n    inputs.forEach(input => input.addEventListener('change', () => dirty=true))\n    // Handle button events\n    panel.querySelector('button.cancel').addEventListener('click', () => {\n        if ( dirty ){\n            const confirmBtn = _modalConfirm_js__WEBPACK_IMPORTED_MODULE_0__.show('Cancel changes', 'Do you really want to lose these changes?')\n            confirmBtn.addEventListener( 'click', () => {\n                _modalConfirm_js__WEBPACK_IMPORTED_MODULE_0__.hide()\n                hide()\n            })\n        } else {\n            hide()\n        }\n    })\n    if ( edit ){\n        panel.querySelector('button.delete').addEventListener('click', () => {\n            const confirmBtn = _modalConfirm_js__WEBPACK_IMPORTED_MODULE_0__.show('Delete link', 'Do you really want to delete this link?')\n            confirmBtn.addEventListener( 'click', () => {\n                _modalConfirm_js__WEBPACK_IMPORTED_MODULE_0__.hide()\n                deleteItem() \n            })\n        })\n    }\n    panel.querySelector('form').addEventListener('submit', event => {\n        event.preventDefault()\n        save()\n    })\n    // Add to dom, position and focus the input\n    document.querySelector('body').appendChild(panel)\n    const href = panel.querySelector('form #href')\n    href.focus()\n    href.setSelectionRange(href.value.length, href.value.length)\n    // Add transition class\n    setTimeout( ()=>panel.classList.add('show'),10 )\n}\n\n// -----------------------------------------------------------------------------\n// @section Save changes\n// -----------------------------------------------------------------------------\n\nfunction save(){\n    console.log('Save changes')\n    // Create new link and add to the editor?\n    if ( linkData.id == '' ){\n        linkData.id = generateUid()\n        linkData.href = panel.querySelector('form #href').value.trim()\n        insert()\n    }\n    setTimeout( ()=>updateDomDelayed(), 10)\n} \n\nfunction insert(){\n    const domLink = document.createElement('a')\n    domLink.id = linkData.id\n    domLink.href = linkData.href\n    domLink.setAttribute('contenteditable', 'false')\n    domLink.innerText = ' '\n    const parent = range.startContainer.parentNode\n    let preText = range.startContainer.textContent.substring(0,range.startOffset)\n    let postText\n    if ( range.collapsed ){\n        postText = range.startContainer.textContent.substring(range.startOffset)\n        // Insert leading and trailing spaces if needed\n        if ( preText.charAt(preText.length+1) != ' ' ){\n            preText = preText + ' '\n        }\n        if ( postText.charAt(0) != ' ' ){\n            postText = ' ' + postText\n        }\n    } else {\n        postText = range.startContainer.textContent.substring(range.endOffset)\n    }\n    if ( preText ) {\n        parent.insertBefore(document.createTextNode(preText), range.startContainer)\n    }\n    parent.insertBefore(domLink, range.startContainer)\n    if ( postText ) {\n        parent.insertBefore(document.createTextNode(postText), range.startContainer)\n    }\n    range.startContainer.remove()\n}\n\nfunction updateDomDelayed(){\n    // Update dom\n    const form = panel.querySelector('form')\n    const domLink = editorNode.querySelector(`a#${linkData.id}`)\n    domLink.href = form.querySelector('#href').value.trim()\n    let label = form.querySelector('#label').value.trim()\n    if ( label == '' ){\n        label = domLink.href\n    }\n    domLink.innerText = label\n    // Add event handler\n    format(domLink)\n    // Close the edit pane\n    hide()\n}\n\n\n\n// -----------------------------------------------------------------------------\n// @section Delete link\n// -----------------------------------------------------------------------------\n\nfunction deleteItem(){\n    // @todo Remove link from the editor\n    const domLink = editorNode.querySelector(`a#${linkData.id}`)\n    domLink.remove()\n    hide()\n}\n\n// -----------------------------------------------------------------------------\n// @section Clear panel\n// -----------------------------------------------------------------------------\n\n\n// function delayedRemove(){\n//     panel.remove()\n//     panel = null\n// }\n\nfunction hide(){\n    panel.classList.remove('show')\n    panel.remove()\n    panel = null\n    // setTimeout( ()=>delayedRemove(), 500 )\n}\n\n// function getNewNode(node){\n//     let matched = false\n//     while ( !matched  ){\n//         if ( node.tagName === 'A' ){\n//             matched = node\n//         }\n//         node = node.parentNode\n//     }\n//     return matched\n// }\n\n\n\nfunction clean(node){\n    console.log('clean link',node)\n    node.removeAttribute('id')\n    node.removeAttribute('contenteditable')\n    return node\n}\n\nfunction format( domLink ){\n    // Click event handling - first time and after reformatting\n    domLink.id = generateUid()\n    domLink.setAttribute('contenteditable',false)\n    domLink.addEventListener('click', event => {\n        event.preventDefault()\n        edit(domLink) \n    })\n}\n\nfunction addEventHandlers(){\n    const domLinks = editorNode.querySelectorAll('a')\n    domLinks.forEach( domLink => domLink.addEventListener('click', event => {\n        event.preventDefault()\n        edit(domLink) \n    }))\n}\n\nfunction form(link,edit){\n    let title = 'Create link'\n    let delBtn = ''\n    let href = 'http://'\n    let label = link.label\n    if ( edit) {\n        title = 'Edit link'\n        delBtn = `<button type=\"button\" class=\"delete\">Delete</button>`\n        href = link.href\n    }\n    return `\n        <div class=\"edit-panel-container\">\n            <div class=\"edit-panel-header\">\n                <h3 class=\"edit-panel-title\">${title}</h3>\n            </div>\n            <div class=\"edit-panel-body\">\n                <form>\n                    <div class=\"form-input\">\n                        <label for=\"href\">URL</label>\n                        <input id=\"href\" type=\"url\" class=\"form-control\" placeholder=\"URL\" required value=\"${href}\">\n                    </div>\n                    <div class=\"form-input\">\n                        <label for=\"label\">Label (optional)</label>\n                        <input id=\"label\" type=\"text\" class=\"form-control\" placeholder=\"Label\" value=\"${label}\">\n                    </div>\n                    <div class=\"buttons\">\n                        <button type=\"button\" class=\"cancel\">Cancel</button>\n                        ${delBtn}\n                        <button type=\"submit\" class=\"save\">Save</button>\n                    </div>\n                </form>\n            </div>\n        </div>`\n}\n\nfunction generateUid(){\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n}\n\n// -----------------------------------------------------------------------------\n// @section Exports\n// -----------------------------------------------------------------------------\n\n\nconst options = {init, addEventHandlers, clean}\nconst button = new _ToolbarButton_js__WEBPACK_IMPORTED_MODULE_1__.default( 'custom', 'A', 'Link', _icons_js__WEBPACK_IMPORTED_MODULE_2__.link, click, options ) \nconst buttons = [button]\n\n//# sourceURL=webpack://AJE/./src/js/plugins/links.js?");

/***/ }),

/***/ "./src/js/plugins/mentions.js":
/*!************************************!*\
  !*** ./src/js/plugins/mentions.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initPeople\": () => (/* binding */ initPeople),\n/* harmony export */   \"buttons\": () => (/* binding */ buttons)\n/* harmony export */ });\n/* harmony import */ var _ToolbarButton_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ToolbarButton.js */ \"./src/js/plugins/ToolbarButton.js\");\n/* harmony import */ var _icons_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icons.js */ \"./src/js/plugins/icons.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers.js */ \"./src/js/helpers.js\");\n\n\n;\n\n\n\nlet dataListOptions = ''\nlet range\nlet panel = null\nlet filterInput = ''\n\nfunction getPosition(dialogue, range){\n    let pos\n    // If this is not a text node then get the first text node\n    // Can happen at the start of a line when backspace to the start\n    if ( range.startContainer.nodeType !== 3 ){\n        if ( range.startContainer.childNodes.length>0 ){\n            let node = range.startContainer.childNodes[0]\n            pos = node.getBoundingClientRect()\n        } else {\n            pos = {x:editor.offsetLeft, y:editor.offsetTop}\n        }\n    // Text node\n    } else {\n        pos = range.getBoundingClientRect()\n        console.log('text node const ',pos)\n    }\n    if ( (pos.x + dialogue.outerWidth) > window.innerWidth ){\n        pos.x = window.innerWidth - dialogue.outerWidth - 20;\n    }\n    if ( (pos.y + dialogue.outerHeight) > window.innerHeight ){\n        pos.y = window.innerHeight - dialogue.outerHeight - 40;\n    }\n    return pos\n} \n\n\nfunction form(){\n    return `\n        <div class=\"mentions-content\">\n            <input list=\"people-list\" type=\"text\"/>\n            <datalist id=\"people-list\">${dataListOptions}</datalist>\n        </div>`\n}\n\nfunction handleKeyup(e){\n    console.log('key',e.target)\n    console.log('key',e.key)\n    console.log('shift',e.shiftKey)\n    e.stopPropagation()\n    if ( e.key=='Escape' ){\n        hide()\n    } else if ( e.key=='Enter' ){\n        insert(filterInput.value.trim())\n    }\n}\n\nfunction click(rng){\n    if ( rng === false ){\n        console.log('No range selected')\n        return\n    }\n    range = rng\n    panel = document.createElement('DIV')\n    panel.id = 'mentions'\n    panel.classList.add('mentions-panel')\n    panel.innerHTML = form()\n    panel.addEventListener('click',()=>hide())\n    panel.addEventListener('keyup', e=>handleKeyup(e))\n    // Filtering using native html approach\n    filterInput = panel.querySelector('input')\n    // Add to dom\n    document.querySelector('body').appendChild(panel)\n    // Position\n    let dialogue = document.querySelector('.mentions-content')\n    const position = getPosition(dialogue, range)\n    dialogue.style.top = `${position.y}px`\n    dialogue.style.left = `${position.x}px`\n    // Focus the input\n    filterInput.focus()\n}\n\nfunction hide(){\n    panel.remove()\n    panel = null\n}\n\nfunction insert(person){\n    let contents = range.startContainer.textContent\n    let offset   = range.startOffset\n    let before   = contents.substring(0,offset)\n    let after    = contents.substring(offset)\n    // Add space before?\n    if ( contents.charCodeAt(offset-1) !== 32){\n        person = ' ' + person\n    }\n    // Add space after & optional remove @\n    if ( offset<contents.length && contents.charCodeAt(offset) !== 32){\n        if ( after != '' && after.charAt(0) === '@'){\n            after = after.slice(1, after.length-1)\n        }\n        person = person + ' '\n    }\n    range.startContainer.textContent = before + person + after\n    // Move offset to the end of the newly inserted person\n    offset += person.length\n    range = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setCursor)( range.startContainer, offset )\n    hide()\n}\n\n// function setCursor( node, offset ){\n//     let rng = document.createRange()\n//     let sel = window.getSelection()\n//     rng.setStart(node, offset);\n//     rng.collapse(true);\n//     sel.removeAllRanges();\n//     sel.addRange(rng);\n//     return rng;\n// }\n\n\n\n// -----------------------------------------------------------------------------\n// @section Exports\n// -----------------------------------------------------------------------------\n\n\nconst initPeople = function(people){\n    people = people.sort()\n    dataListOptions = ''\n    people.forEach( person => {\n        dataListOptions += `<option>${person}</option>`\n    })\n}\n\nconst options = {shortcut:'@'}\nconst button = new _ToolbarButton_js__WEBPACK_IMPORTED_MODULE_0__.default( 'custom', 'mention', 'Mention', _icons_js__WEBPACK_IMPORTED_MODULE_1__.person, click, options ) \nconst buttons = [button]\n\n//# sourceURL=webpack://AJE/./src/js/plugins/mentions.js?");

/***/ }),

/***/ "./src/js/plugins/modalConfirm.js":
/*!****************************************!*\
  !*** ./src/js/plugins/modalConfirm.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hide\": () => (/* binding */ hide),\n/* harmony export */   \"show\": () => (/* binding */ show)\n/* harmony export */ });\n\n\nlet panel = null\n\nfunction form(title,message){\n    return `\n        <div class=\"modal-confirm-container\">\n            <header class=\"modal-confirm-header\">\n                <h3 class=\"modal-confirm-title\">${title}</h3>\n            </header>\n            <div class=\"modal-confirm-message\">${message}</div>\n            <div class=\"modal-confirm-buttons\">\n                <button type=\"button\" class=\"cancel\">No - stay here</button>\n                <button type=\"button\" class=\"confirm\">Yes - lose changes</button>\n            </div>\n        </div>`\n}\n\nfunction delayedRemove(){\n    panel.remove()\n    panel = null\n}\n\nfunction delayedShow(){\n    panel.classList.add('show')\n}\n\n\n// -----------------------------------------------------------------------------\n// @section Exports\n// -----------------------------------------------------------------------------\n\nconst hide = function(){\n    panel.classList.remove('show')\n    setTimeout( ()=>delayedRemove(), 500 )\n}\n\nconst show = function( title, message ){\n    panel = document.createElement('DIV')\n    panel.classList.add('modal-confirm')\n    panel.innerHTML = form(title,message)\n    panel.querySelector('button.cancel').addEventListener('click', event => {\n        event.stopPropagation()\n        hide()\n    })\n    document.querySelector('body').appendChild(panel)\n    // Invoke with arrow function, otherwise this will be the current window\n    setTimeout( () => delayedShow(), 10 )\n    return panel.querySelector('button.confirm')\n}\n\n\n//# sourceURL=webpack://AJE/./src/js/plugins/modalConfirm.js?");

/***/ }),

/***/ "./src/js/templates.js":
/*!*****************************!*\
  !*** ./src/js/templates.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"editor\": () => (/* binding */ editor)\n/* harmony export */ });\nfunction editorToolbarButton(button){\n    const {type, tag, label, icon} = button\n    // e.g. icon \"bi-eye\"\n    // data-bs-toggle=\"button\" allows the active state to be shown by adding\n    // the class \"active\" and aria-pressed=\"true\"(for assistive tech)\n    return `\n        <button id=\"${tag}\" type=\"button\" class=\"btn btn-light ${type}\" title=\"${label}\">\n            ${icon}\n        </button>`\n}\n\nfunction editorToolBarGroup(title,html){\n    return `<div class=\"editor-toolbar-group block\" role=\"group\" title=\"${title}\">${html}</div>`\n}\n\nfunction editorToolbar(buttons){\n    let buttonsHtml = ''\n    let groups = []\n    console.log('buttons.length',buttons.length)\n    buttons.forEach((button,index)=>{\n        buttonsHtml += editorToolbarButton(button)\n        const nextType = index==buttons.length-1 ? '' : buttons[index+1].type\n        // Found end of a group?\n        if ( button.type != nextType ){\n            console.log('found new group at button',button.tag)\n            const title = `${button.type} buttons`\n            groups.push( editorToolBarGroup(title,buttonsHtml) )\n            buttonsHtml = ''\n        }\n    })\n    console.log('groups',groups)\n    return groups.join('<span class=\"editor-toolbar-group-separator\">|</span>')\n}\n\nconst editor = function(buttons,options){\n    const toolbar = editorToolbar(buttons)\n    let classes = ''\n    if ( options.headingNumbers == 'on' ){\n        classes += 'heading-numbers'\n    }\n    return `\n        <div class=\"editor-container\">\n            <div class=\"editor-toolbar\">\n                ${toolbar}\n            </div>\n            <div class=\"editor-body ${classes}\" contenteditable=\"true\">\n                ...\n            </div>\n        </div>`\n}\n\n//# sourceURL=webpack://AJE/./src/js/templates.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});